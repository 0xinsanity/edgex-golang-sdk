/*
Http Gateway

Contains interface documents such as accounts, assets, transactions, etc.

API version: v1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// Class03AccountPrivateApiAPIService Class03AccountPrivateApiAPI service
type Class03AccountPrivateApiAPIService service

type ApiGetAccountAssetRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	accountId *string
}

// 账户id
func (r ApiGetAccountAssetRequest) AccountId(accountId string) ApiGetAccountAssetRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetAccountAssetRequest) Execute() (*ResultGetAccountAsset, *http.Response, error) {
	return r.ApiService.GetAccountAssetExecute(r)
}

/*
GetAccountAsset 获取账户资产相关数据

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountAssetRequest
*/
func (a *Class03AccountPrivateApiAPIService) GetAccountAsset(ctx context.Context) ApiGetAccountAssetRequest {
	return ApiGetAccountAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultGetAccountAsset
func (a *Class03AccountPrivateApiAPIService) GetAccountAssetExecute(r ApiGetAccountAssetRequest) (*ResultGetAccountAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultGetAccountAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetAccountAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getAccountAsset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountAssetSnapshotPageRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	coinId *string
	accountId *string
	size *string
	offsetData *string
	filterTimeTag *string
	filterStartTimeInclusive *string
	filterEndTimeExclusive *string
}

// 获取指定币种的资产快照
func (r ApiGetAccountAssetSnapshotPageRequest) CoinId(coinId string) ApiGetAccountAssetSnapshotPageRequest {
	r.coinId = &coinId
	return r
}

// 账户id
func (r ApiGetAccountAssetSnapshotPageRequest) AccountId(accountId string) ApiGetAccountAssetSnapshotPageRequest {
	r.accountId = &accountId
	return r
}

// 获取数量。必须大于0且小于等于1000
func (r ApiGetAccountAssetSnapshotPageRequest) Size(size string) ApiGetAccountAssetSnapshotPageRequest {
	r.size = &size
	return r
}

// 翻页获取偏移。如果不填或者为空串，则获取第一页
func (r ApiGetAccountAssetSnapshotPageRequest) OffsetData(offsetData string) ApiGetAccountAssetSnapshotPageRequest {
	r.offsetData = &offsetData
	return r
}

// 指定时间tag 不填或者为0的话按小时返回快照，1按天返回快照
func (r ApiGetAccountAssetSnapshotPageRequest) FilterTimeTag(filterTimeTag string) ApiGetAccountAssetSnapshotPageRequest {
	r.filterTimeTag = &filterTimeTag
	return r
}

// 过滤获取指定开始时间的资产快照 (包含)，不填或者为0的话就从最早开始
func (r ApiGetAccountAssetSnapshotPageRequest) FilterStartTimeInclusive(filterStartTimeInclusive string) ApiGetAccountAssetSnapshotPageRequest {
	r.filterStartTimeInclusive = &filterStartTimeInclusive
	return r
}

// 过滤获取指定结束时间的资产快照 (不包含)，不填或者为0的话就到最近
func (r ApiGetAccountAssetSnapshotPageRequest) FilterEndTimeExclusive(filterEndTimeExclusive string) ApiGetAccountAssetSnapshotPageRequest {
	r.filterEndTimeExclusive = &filterEndTimeExclusive
	return r
}

func (r ApiGetAccountAssetSnapshotPageRequest) Execute() (*ResultPageDataAccountAssetSnapshot, *http.Response, error) {
	return r.ApiService.GetAccountAssetSnapshotPageExecute(r)
}

/*
GetAccountAssetSnapshotPage 根据账号id翻页获取历史资产快照

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountAssetSnapshotPageRequest
*/
func (a *Class03AccountPrivateApiAPIService) GetAccountAssetSnapshotPage(ctx context.Context) ApiGetAccountAssetSnapshotPageRequest {
	return ApiGetAccountAssetSnapshotPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultPageDataAccountAssetSnapshot
func (a *Class03AccountPrivateApiAPIService) GetAccountAssetSnapshotPageExecute(r ApiGetAccountAssetSnapshotPageRequest) (*ResultPageDataAccountAssetSnapshot, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultPageDataAccountAssetSnapshot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetAccountAssetSnapshotPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getAccountAssetSnapshotPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coinId == nil {
		return localVarReturnValue, nil, reportError("coinId is required and must be specified")
	}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.offsetData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetData", r.offsetData, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "coinId", r.coinId, "form", "")
	if r.filterTimeTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterTimeTag", r.filterTimeTag, "form", "")
	}
	if r.filterStartTimeInclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterStartTimeInclusive", r.filterStartTimeInclusive, "form", "")
	}
	if r.filterEndTimeExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterEndTimeExclusive", r.filterEndTimeExclusive, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountByIdRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	accountId *string
}

// 账户id
func (r ApiGetAccountByIdRequest) AccountId(accountId string) ApiGetAccountByIdRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetAccountByIdRequest) Execute() (*ResultAccount, *http.Response, error) {
	return r.ApiService.GetAccountByIdExecute(r)
}

/*
GetAccountById 根据账户id获取账户信息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountByIdRequest
*/
func (a *Class03AccountPrivateApiAPIService) GetAccountById(ctx context.Context) ApiGetAccountByIdRequest {
	return ApiGetAccountByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultAccount
func (a *Class03AccountPrivateApiAPIService) GetAccountByIdExecute(r ApiGetAccountByIdRequest) (*ResultAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetAccountById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getAccountById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountDeleverageLightRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	accountId *string
}

// 账户id
func (r ApiGetAccountDeleverageLightRequest) AccountId(accountId string) ApiGetAccountDeleverageLightRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetAccountDeleverageLightRequest) Execute() (*ResultGetAccountDeleverageLight, *http.Response, error) {
	return r.ApiService.GetAccountDeleverageLightExecute(r)
}

/*
GetAccountDeleverageLight 获取账户下所有仓位减仓ADL灯

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountDeleverageLightRequest
*/
func (a *Class03AccountPrivateApiAPIService) GetAccountDeleverageLight(ctx context.Context) ApiGetAccountDeleverageLightRequest {
	return ApiGetAccountDeleverageLightRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultGetAccountDeleverageLight
func (a *Class03AccountPrivateApiAPIService) GetAccountDeleverageLightExecute(r ApiGetAccountDeleverageLightRequest) (*ResultGetAccountDeleverageLight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultGetAccountDeleverageLight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetAccountDeleverageLight")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getAccountDeleverageLight"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountPageRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	size *string
	offsetData *string
}

// 获取数量。必须大于0且小于等于100
func (r ApiGetAccountPageRequest) Size(size string) ApiGetAccountPageRequest {
	r.size = &size
	return r
}

// 翻页获取偏移。如果不填或者为空串，则获取第一页
func (r ApiGetAccountPageRequest) OffsetData(offsetData string) ApiGetAccountPageRequest {
	r.offsetData = &offsetData
	return r
}

func (r ApiGetAccountPageRequest) Execute() (*ResultPageDataAccount, *http.Response, error) {
	return r.ApiService.GetAccountPageExecute(r)
}

/*
GetAccountPage 根据用户id翻页获取账户信息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountPageRequest
*/
func (a *Class03AccountPrivateApiAPIService) GetAccountPage(ctx context.Context) ApiGetAccountPageRequest {
	return ApiGetAccountPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultPageDataAccount
func (a *Class03AccountPrivateApiAPIService) GetAccountPageExecute(r ApiGetAccountPageRequest) (*ResultPageDataAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultPageDataAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetAccountPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getAccountPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.offsetData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetData", r.offsetData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollateralByCoinIdRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	accountId *string
	contractIdList *string
}

// 账户id
func (r ApiGetCollateralByCoinIdRequest) AccountId(accountId string) ApiGetCollateralByCoinIdRequest {
	r.accountId = &accountId
	return r
}

// 指定的合约id
func (r ApiGetCollateralByCoinIdRequest) ContractIdList(contractIdList string) ApiGetCollateralByCoinIdRequest {
	r.contractIdList = &contractIdList
	return r
}

func (r ApiGetCollateralByCoinIdRequest) Execute() (*ResultListPosition, *http.Response, error) {
	return r.ApiService.GetCollateralByCoinIdExecute(r)
}

/*
GetCollateralByCoinId 根据账号id和合约id批量获取仓位

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCollateralByCoinIdRequest
*/
func (a *Class03AccountPrivateApiAPIService) GetCollateralByCoinId(ctx context.Context) ApiGetCollateralByCoinIdRequest {
	return ApiGetCollateralByCoinIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultListPosition
func (a *Class03AccountPrivateApiAPIService) GetCollateralByCoinIdExecute(r ApiGetCollateralByCoinIdRequest) (*ResultListPosition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListPosition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetCollateralByCoinId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getPositionByContractId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.contractIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractIdList", r.contractIdList, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollateralByCoinId1Request struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	accountId *string
	coinIdList *string
}

// 账户id
func (r ApiGetCollateralByCoinId1Request) AccountId(accountId string) ApiGetCollateralByCoinId1Request {
	r.accountId = &accountId
	return r
}

// 获取指定币种的抵押品信息，如果不填则获取所有抵押品信息
func (r ApiGetCollateralByCoinId1Request) CoinIdList(coinIdList string) ApiGetCollateralByCoinId1Request {
	r.coinIdList = &coinIdList
	return r
}

func (r ApiGetCollateralByCoinId1Request) Execute() (*ResultListCollateral, *http.Response, error) {
	return r.ApiService.GetCollateralByCoinId1Execute(r)
}

/*
GetCollateralByCoinId1 根据账号id和抵押品coinId批量获取抵押品信息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCollateralByCoinId1Request
*/
func (a *Class03AccountPrivateApiAPIService) GetCollateralByCoinId1(ctx context.Context) ApiGetCollateralByCoinId1Request {
	return ApiGetCollateralByCoinId1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultListCollateral
func (a *Class03AccountPrivateApiAPIService) GetCollateralByCoinId1Execute(r ApiGetCollateralByCoinId1Request) (*ResultListCollateral, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListCollateral
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetCollateralByCoinId1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getCollateralByCoinId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.coinIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coinIdList", r.coinIdList, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollateralTransactionByIdRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	accountId *string
	collateralTransactionIdList *string
}

// 账户id
func (r ApiGetCollateralTransactionByIdRequest) AccountId(accountId string) ApiGetCollateralTransactionByIdRequest {
	r.accountId = &accountId
	return r
}

// 抵押品明细id
func (r ApiGetCollateralTransactionByIdRequest) CollateralTransactionIdList(collateralTransactionIdList string) ApiGetCollateralTransactionByIdRequest {
	r.collateralTransactionIdList = &collateralTransactionIdList
	return r
}

func (r ApiGetCollateralTransactionByIdRequest) Execute() (*ResultListCollateralTransaction, *http.Response, error) {
	return r.ApiService.GetCollateralTransactionByIdExecute(r)
}

/*
GetCollateralTransactionById 根据账户id和抵押品明细id批量获取成抵押品明细

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCollateralTransactionByIdRequest
*/
func (a *Class03AccountPrivateApiAPIService) GetCollateralTransactionById(ctx context.Context) ApiGetCollateralTransactionByIdRequest {
	return ApiGetCollateralTransactionByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultListCollateralTransaction
func (a *Class03AccountPrivateApiAPIService) GetCollateralTransactionByIdExecute(r ApiGetCollateralTransactionByIdRequest) (*ResultListCollateralTransaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListCollateralTransaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetCollateralTransactionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getCollateralTransactionById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.collateralTransactionIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collateralTransactionIdList", r.collateralTransactionIdList, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollateralTransactionPageRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	accountId *string
	size *string
	offsetData *string
	filterCoinIdList *string
	filterTypeList *string
	filterStartCreatedTimeInclusive *string
	filterEndCreatedTimeExclusive *string
}

// 账户id
func (r ApiGetCollateralTransactionPageRequest) AccountId(accountId string) ApiGetCollateralTransactionPageRequest {
	r.accountId = &accountId
	return r
}

// 获取数量。必须大于0且小于等于100
func (r ApiGetCollateralTransactionPageRequest) Size(size string) ApiGetCollateralTransactionPageRequest {
	r.size = &size
	return r
}

// 翻页获取偏移。如果不填或者为空串，则获取第一页
func (r ApiGetCollateralTransactionPageRequest) OffsetData(offsetData string) ApiGetCollateralTransactionPageRequest {
	r.offsetData = &offsetData
	return r
}

// 获取指定币种的抵押品流水，如果不填则获取所有抵押品流水
func (r ApiGetCollateralTransactionPageRequest) FilterCoinIdList(filterCoinIdList string) ApiGetCollateralTransactionPageRequest {
	r.filterCoinIdList = &filterCoinIdList
	return r
}

// 获取指定抵押品变动明细类型的流水，如果不填则获取所有抵押品流水
func (r ApiGetCollateralTransactionPageRequest) FilterTypeList(filterTypeList string) ApiGetCollateralTransactionPageRequest {
	r.filterTypeList = &filterTypeList
	return r
}

// 过滤获取指定开始时间创建的抵押品流水 (包含)，不填或者为0的话就从最早开始
func (r ApiGetCollateralTransactionPageRequest) FilterStartCreatedTimeInclusive(filterStartCreatedTimeInclusive string) ApiGetCollateralTransactionPageRequest {
	r.filterStartCreatedTimeInclusive = &filterStartCreatedTimeInclusive
	return r
}

// 过滤获取指定结束时间创建的抵押品流水 (不包含)，不填或者为0的话就到最近
func (r ApiGetCollateralTransactionPageRequest) FilterEndCreatedTimeExclusive(filterEndCreatedTimeExclusive string) ApiGetCollateralTransactionPageRequest {
	r.filterEndCreatedTimeExclusive = &filterEndCreatedTimeExclusive
	return r
}

func (r ApiGetCollateralTransactionPageRequest) Execute() (*ResultPageDataCollateralTransaction, *http.Response, error) {
	return r.ApiService.GetCollateralTransactionPageExecute(r)
}

/*
GetCollateralTransactionPage 根据账户id翻页获取抵押品明细

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCollateralTransactionPageRequest
*/
func (a *Class03AccountPrivateApiAPIService) GetCollateralTransactionPage(ctx context.Context) ApiGetCollateralTransactionPageRequest {
	return ApiGetCollateralTransactionPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultPageDataCollateralTransaction
func (a *Class03AccountPrivateApiAPIService) GetCollateralTransactionPageExecute(r ApiGetCollateralTransactionPageRequest) (*ResultPageDataCollateralTransaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultPageDataCollateralTransaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetCollateralTransactionPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getCollateralTransactionPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.offsetData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetData", r.offsetData, "form", "")
	}
	if r.filterCoinIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterCoinIdList", r.filterCoinIdList, "form", "")
	}
	if r.filterTypeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterTypeList", r.filterTypeList, "form", "")
	}
	if r.filterStartCreatedTimeInclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterStartCreatedTimeInclusive", r.filterStartCreatedTimeInclusive, "form", "")
	}
	if r.filterEndCreatedTimeExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterEndCreatedTimeExclusive", r.filterEndCreatedTimeExclusive, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPositionTermPageRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	accountId *string
	size *string
	offsetData *string
	filterCoinIdList *string
	filterContractIdList *string
	filterIsLongPosition *string
	filterStartCreatedTimeInclusive *string
	filterEndCreatedTimeExclusive *string
}

// 账户id
func (r ApiGetPositionTermPageRequest) AccountId(accountId string) ApiGetPositionTermPageRequest {
	r.accountId = &accountId
	return r
}

// 获取数量。必须大于0且小于等于100
func (r ApiGetPositionTermPageRequest) Size(size string) ApiGetPositionTermPageRequest {
	r.size = &size
	return r
}

// 翻页获取偏移。如果不填或者为空串，则获取第一页
func (r ApiGetPositionTermPageRequest) OffsetData(offsetData string) ApiGetPositionTermPageRequest {
	r.offsetData = &offsetData
	return r
}

// 获取指定币种的仓位term信息，如果不填则获取所有仓位term信息
func (r ApiGetPositionTermPageRequest) FilterCoinIdList(filterCoinIdList string) ApiGetPositionTermPageRequest {
	r.filterCoinIdList = &filterCoinIdList
	return r
}

// 获取指定合约的仓位term信息，如果不填则获取所有仓位term信息
func (r ApiGetPositionTermPageRequest) FilterContractIdList(filterContractIdList string) ApiGetPositionTermPageRequest {
	r.filterContractIdList = &filterContractIdList
	return r
}

// 获取制定方向的仓位term信息，如果不填则获取所有仓位term信息
func (r ApiGetPositionTermPageRequest) FilterIsLongPosition(filterIsLongPosition string) ApiGetPositionTermPageRequest {
	r.filterIsLongPosition = &filterIsLongPosition
	return r
}

// 过滤获取指定开始时间创建的抵押品流水 (包含)，不填或者为0的话就从最早开始
func (r ApiGetPositionTermPageRequest) FilterStartCreatedTimeInclusive(filterStartCreatedTimeInclusive string) ApiGetPositionTermPageRequest {
	r.filterStartCreatedTimeInclusive = &filterStartCreatedTimeInclusive
	return r
}

// 过滤获取指定结束时间创建的抵押品流水 (不包含)，不填或者为0的话就到最近
func (r ApiGetPositionTermPageRequest) FilterEndCreatedTimeExclusive(filterEndCreatedTimeExclusive string) ApiGetPositionTermPageRequest {
	r.filterEndCreatedTimeExclusive = &filterEndCreatedTimeExclusive
	return r
}

func (r ApiGetPositionTermPageRequest) Execute() (*ResultPageDataPositionTerm, *http.Response, error) {
	return r.ApiService.GetPositionTermPageExecute(r)
}

/*
GetPositionTermPage 根据账号id翻页获取持仓term信息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPositionTermPageRequest
*/
func (a *Class03AccountPrivateApiAPIService) GetPositionTermPage(ctx context.Context) ApiGetPositionTermPageRequest {
	return ApiGetPositionTermPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultPageDataPositionTerm
func (a *Class03AccountPrivateApiAPIService) GetPositionTermPageExecute(r ApiGetPositionTermPageRequest) (*ResultPageDataPositionTerm, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultPageDataPositionTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetPositionTermPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getPositionTermPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.offsetData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetData", r.offsetData, "form", "")
	}
	if r.filterCoinIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterCoinIdList", r.filterCoinIdList, "form", "")
	}
	if r.filterContractIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterContractIdList", r.filterContractIdList, "form", "")
	}
	if r.filterIsLongPosition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIsLongPosition", r.filterIsLongPosition, "form", "")
	}
	if r.filterStartCreatedTimeInclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterStartCreatedTimeInclusive", r.filterStartCreatedTimeInclusive, "form", "")
	}
	if r.filterEndCreatedTimeExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterEndCreatedTimeExclusive", r.filterEndCreatedTimeExclusive, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPositionTransactionByIdRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	accountId *string
	positionTransactionIdList *string
}

// 账户id
func (r ApiGetPositionTransactionByIdRequest) AccountId(accountId string) ApiGetPositionTransactionByIdRequest {
	r.accountId = &accountId
	return r
}

// 仓位流水id
func (r ApiGetPositionTransactionByIdRequest) PositionTransactionIdList(positionTransactionIdList string) ApiGetPositionTransactionByIdRequest {
	r.positionTransactionIdList = &positionTransactionIdList
	return r
}

func (r ApiGetPositionTransactionByIdRequest) Execute() (*ResultListPositionTransaction, *http.Response, error) {
	return r.ApiService.GetPositionTransactionByIdExecute(r)
}

/*
GetPositionTransactionById 根据账户id和仓位流水id批量获取仓位流水

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPositionTransactionByIdRequest
*/
func (a *Class03AccountPrivateApiAPIService) GetPositionTransactionById(ctx context.Context) ApiGetPositionTransactionByIdRequest {
	return ApiGetPositionTransactionByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultListPositionTransaction
func (a *Class03AccountPrivateApiAPIService) GetPositionTransactionByIdExecute(r ApiGetPositionTransactionByIdRequest) (*ResultListPositionTransaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultListPositionTransaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetPositionTransactionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getPositionTransactionById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.positionTransactionIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positionTransactionIdList", r.positionTransactionIdList, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPositionTransactionPageRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	accountId *string
	size *string
	offsetData *string
	filterCoinIdList *string
	filterContractIdList *string
	filterTypeList *string
	filterStartCreatedTimeInclusive *string
	filterEndCreatedTimeExclusive *string
	filterCloseOnly *string
	filterOpenOnly *string
}

// 账户id
func (r ApiGetPositionTransactionPageRequest) AccountId(accountId string) ApiGetPositionTransactionPageRequest {
	r.accountId = &accountId
	return r
}

// 获取数量。必须大于0且小于等于100
func (r ApiGetPositionTransactionPageRequest) Size(size string) ApiGetPositionTransactionPageRequest {
	r.size = &size
	return r
}

// 翻页获取偏移。如果不填或者为空串，则获取第一页
func (r ApiGetPositionTransactionPageRequest) OffsetData(offsetData string) ApiGetPositionTransactionPageRequest {
	r.offsetData = &offsetData
	return r
}

// 获取指定币种的仓位流水，如果不填则获取所有抵押品流水
func (r ApiGetPositionTransactionPageRequest) FilterCoinIdList(filterCoinIdList string) ApiGetPositionTransactionPageRequest {
	r.filterCoinIdList = &filterCoinIdList
	return r
}

// 获取指定合约的仓位流水，如果不填则获取所有仓位流水
func (r ApiGetPositionTransactionPageRequest) FilterContractIdList(filterContractIdList string) ApiGetPositionTransactionPageRequest {
	r.filterContractIdList = &filterContractIdList
	return r
}

// 获取指定持仓变动明细类型的仓位流水，如果不填则获取所有仓位流水
func (r ApiGetPositionTransactionPageRequest) FilterTypeList(filterTypeList string) ApiGetPositionTransactionPageRequest {
	r.filterTypeList = &filterTypeList
	return r
}

// 过滤获取指定开始时间创建的仓位流水 (包含)，不填或者为0的话就从最早开始
func (r ApiGetPositionTransactionPageRequest) FilterStartCreatedTimeInclusive(filterStartCreatedTimeInclusive string) ApiGetPositionTransactionPageRequest {
	r.filterStartCreatedTimeInclusive = &filterStartCreatedTimeInclusive
	return r
}

// 过滤获取指定结束时间创建的仓位流水 (不包含)，不填或者为0的话就到最近
func (r ApiGetPositionTransactionPageRequest) FilterEndCreatedTimeExclusive(filterEndCreatedTimeExclusive string) ApiGetPositionTransactionPageRequest {
	r.filterEndCreatedTimeExclusive = &filterEndCreatedTimeExclusive
	return r
}

// 是否仅返回包含平仓的仓位流水。true：只返回有平仓的流水，false：返回所有流水
func (r ApiGetPositionTransactionPageRequest) FilterCloseOnly(filterCloseOnly string) ApiGetPositionTransactionPageRequest {
	r.filterCloseOnly = &filterCloseOnly
	return r
}

// 是否仅返回包含开仓的仓位流水。true：只返回有开仓的流水，false：返回所有流水
func (r ApiGetPositionTransactionPageRequest) FilterOpenOnly(filterOpenOnly string) ApiGetPositionTransactionPageRequest {
	r.filterOpenOnly = &filterOpenOnly
	return r
}

func (r ApiGetPositionTransactionPageRequest) Execute() (*ResultPageDataPositionTransaction, *http.Response, error) {
	return r.ApiService.GetPositionTransactionPageExecute(r)
}

/*
GetPositionTransactionPage 翻页获取仓位流水

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPositionTransactionPageRequest
*/
func (a *Class03AccountPrivateApiAPIService) GetPositionTransactionPage(ctx context.Context) ApiGetPositionTransactionPageRequest {
	return ApiGetPositionTransactionPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultPageDataPositionTransaction
func (a *Class03AccountPrivateApiAPIService) GetPositionTransactionPageExecute(r ApiGetPositionTransactionPageRequest) (*ResultPageDataPositionTransaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultPageDataPositionTransaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.GetPositionTransactionPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/getPositionTransactionPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.offsetData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetData", r.offsetData, "form", "")
	}
	if r.filterCoinIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterCoinIdList", r.filterCoinIdList, "form", "")
	}
	if r.filterContractIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterContractIdList", r.filterContractIdList, "form", "")
	}
	if r.filterTypeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterTypeList", r.filterTypeList, "form", "")
	}
	if r.filterStartCreatedTimeInclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterStartCreatedTimeInclusive", r.filterStartCreatedTimeInclusive, "form", "")
	}
	if r.filterEndCreatedTimeExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterEndCreatedTimeExclusive", r.filterEndCreatedTimeExclusive, "form", "")
	}
	if r.filterCloseOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterCloseOnly", r.filterCloseOnly, "form", "")
	}
	if r.filterOpenOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterOpenOnly", r.filterOpenOnly, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegisterAccountRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	registerAccountParam *RegisterAccountParam
}

func (r ApiRegisterAccountRequest) RegisterAccountParam(registerAccountParam RegisterAccountParam) ApiRegisterAccountRequest {
	r.registerAccountParam = &registerAccountParam
	return r
}

func (r ApiRegisterAccountRequest) Execute() (*ResultRegisterAccount, *http.Response, error) {
	return r.ApiService.RegisterAccountExecute(r)
}

/*
RegisterAccount 注册账户

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRegisterAccountRequest
*/
func (a *Class03AccountPrivateApiAPIService) RegisterAccount(ctx context.Context) ApiRegisterAccountRequest {
	return ApiRegisterAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultRegisterAccount
func (a *Class03AccountPrivateApiAPIService) RegisterAccountExecute(r ApiRegisterAccountRequest) (*ResultRegisterAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultRegisterAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.RegisterAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/registerAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.registerAccountParam == nil {
		return localVarReturnValue, nil, reportError("registerAccountParam is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.registerAccountParam
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLeverageSettingRequest struct {
	ctx context.Context
	ApiService *Class03AccountPrivateApiAPIService
	updateLeverageSettingParam *UpdateLeverageSettingParam
}

func (r ApiUpdateLeverageSettingRequest) UpdateLeverageSettingParam(updateLeverageSettingParam UpdateLeverageSettingParam) ApiUpdateLeverageSettingRequest {
	r.updateLeverageSettingParam = &updateLeverageSettingParam
	return r
}

func (r ApiUpdateLeverageSettingRequest) Execute() (*ResultVoid, *http.Response, error) {
	return r.ApiService.UpdateLeverageSettingExecute(r)
}

/*
UpdateLeverageSetting 更新账户交易杠杆设置

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateLeverageSettingRequest
*/
func (a *Class03AccountPrivateApiAPIService) UpdateLeverageSetting(ctx context.Context) ApiUpdateLeverageSettingRequest {
	return ApiUpdateLeverageSettingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResultVoid
func (a *Class03AccountPrivateApiAPIService) UpdateLeverageSettingExecute(r ApiUpdateLeverageSettingRequest) (*ResultVoid, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultVoid
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Class03AccountPrivateApiAPIService.UpdateLeverageSetting")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/private/account/updateLeverageSetting"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLeverageSettingParam == nil {
		return localVarReturnValue, nil, reportError("updateLeverageSettingParam is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLeverageSettingParam
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
